# CoreCRM 开发实录 —— 单元测试、测试驱动开发和持续集成

测试是对的，问题是怎么测试。

## 单元测试

单元测试已经是无可争议的最佳开发实践之一。但还是有很多人持反对意见。他们的说法无非是：写测试需要花很多时间，需求又经常变动，一但变动，一大片漫测试作废。这样又浪费时间，又降低效率。

而现实情况是：没有人不测试代码的。哪怕是最牛的开发人员，也需要对自己写的代码进行测试。这一点可以去看《Coders at Work》。虽然有一些“牛人”测试的方法很原始，比如使用 `printf` 来查看运行结果。这其实用现代软件组件来看，就是用 Log。而一但软件变得复杂，涉及十几个，甚至几十个模块相互依赖的时候，看 Log 显然又低效，又费力。很多时候需要添加一些 Log，分析一下是不是这一部分的问题，然后注释掉，再在别的地方再加一些 Log。如此反复。如果是动态语言还好，如果是需要编译的语言，那么这些小的修改最后浪费在编译上的时间也是很多的。

当然，基于现在强大的 IDE 开发工具，还有一种非常方便的测试工具，就是断点调试。使用 Visual Studio 一路杀上来的程序员最需要这种方法了。只要在自己怀疑有问题的地方加一个断点，在这点处的上下文就都能看到了。还能通过单步执行来看到实际的执行路径，看看是不是和自己设计时候想的一样。但是，断点高度的主要功能是在已经知道某一部分有问题的情况下，查找和修复问题。而对于一个团队合作的项目来说，可能一个人的修改，会破坏另一个人的代码（如果两个人的代码存在依赖的话）。这而这和破坏，只有对应的路径被执行到的时候，才会被发现。

最终自动化的测试工具被发明出来解决上面的两个问题。但并不是每个人都接受自动化测试这个想法。原因之一是上面说的“嫌麻烦”。而还有一派则认为：单元测试并不能消除 Bug，所以不值得投入时间和精力去做。持有后一种观点的朋友，很可能是被一些公司的广告给骗了。单元测试本来就不是用来发现 Bug 的工具，如果想发现 Bug，那最好的工具应该是代码的静态分析工具。而单元测试，按照我的理解，应该是使用一组代码来描述系统的功能。

**为什么要用代码描述系统的功能呢？**前面提到系统需求经常会改变。但无论系统需求变成什么样子，最终都有一个可验收的标准。对于整个系统来说，这个不能叫单元测试，应该叫验收测试。不过，如果我们把自己也当成自己写的类或者模块的用户的话，那么这个模块在设计的时候有什么功能，其实也是大致有一个“验收标准”的。而在没有自动测试的时候，我们通常会组合上面的两种方式：写 Log 和断点调试来完成自我测试的。这样的流程，既方便又简单。感觉上也很高效。但正如我一直在说的这个问题：需求会变化的。需求的变化会引发什么后果呢？有时候一整段代码就被废弃了（这时候有根本控制系统来做保护，或者有的人喜欢临时注释掉刚刚不用的代码）。但更多的时候，可能是代码的一小部分不能用了。比如一个函数，一个模块的一部分逻辑。这样的修改，在这个局部是不会有什么问题的。但从整个项目来看，就不可避免的存在风险。比如：A 写了一个计算时间的模块，一开始这个模块的 `GetTime` 返回的是以秒为单位的 epoch 时间。这个模块本来是只有 A 自己用，后来有一个实习生，在写一个不很重要的模块时，需要猎取时间，发现了 A 写的这个正好满足他的需要，就直接使用了。实习结束后，这哥们走人了。然后，系统的需求改变了，`GetTime` 不再返回以秒为单位的 epoch 时间，改成了以毫秒为单位。A 并不知道还有人用他的模块，自己就改了。结果大家一定都知道了：那个实习生写的东西，因为不重要，所以没什么人知道这里出了问题，直到有一天，一个愤怒的用户打电话过来……

**怎么用代码描述系统的功能呢？**就是使用 xUnit 这样的自动化测试工具。一般的测试分三部：Arrange、Act 和 Assert。Arrange 是准备被测对象。一般包括对被测对象的依赖的 mock（就是创建一个“伪装”的依赖对象），和被测对象的创建两部分；Act 就是执行待测的函数（功能）；Assert 部分则是对执行结果的达确认。从更高一层的抽象来描述就是：Arrange 让被测对象处在一个确定的状态，然后通过 Act 对被测对象的状态进行改变，最后通过 Assert 来确认这个变化符合预期。这个过程有时候很简单，比如对于没有副作用的函数，只要给出参数，测试结果就可以了。有时候会很复杂，比如被测对象要操作某种数据，而且对象本身还有状态。

但我也想强调一个经常被说，但可能没什么人当回事的问题：测试代码也是代码，不要写低质量的测试代码。我相信有人和我一样，会犯懒，对于类似的测试代码，直接复制过来，简单改两下就用。这当然不是不可以，但改的时候也应该把这段代码仔细改全。我之前经常犯的一个错误就是“张冠李戴”，也就是只改了一下函数名，别的都没怎么细看，就去运行测试了。这样的结果当然就是得改很多次，才能能测试通过。

我在 《The Art of UnitTesting》这本书里，学到了一个很重要的技巧：在函数名里用下划线分成三段：被测的函数名_输入条件_返回值或后果。通过这样的命名，一个测试的功能就很显然了。以后在全部折叠的时候，也能知道一个函数是在测试什么东西。非常的方便。

## 测试驱动开发



## 集成测试

## 后记

### `GetTime` 的困境

其实在写完`GetTime` 那个例子的时候，我在想单元测试是不是能解决这个问题呢？初步想来，好像也不能避免。因为被测系统一定会对依赖做 Mock，这样，`GetTime` 的返回值其实是“伪造”的，并不能体现原系统的变化。而集成测试可能不会覆盖这样细的部分。我还需要再想一下这个问题。

当然我想有的朋友会想到，Visual Studio 等 IDE 有一个功能就是能查找调用了这个函数的函数。这样在一定程度上是有机会发现这样的问题的。毕竟 IDE 发展这么多年，也对常见的问题提供了解决方案。可能我需要找到另一个更合适的例子来说明问题。